---
description: SwiftUI
alwaysApply: false
---

# SwiftUI

Declarative UI with composable views, state management, and the observation framework.

## State Management

```swift
// @State — view-local mutable state
@State private var count = 0
// @Binding — two-way connection to parent
@Binding var isOn: Bool
// @StateObject — owned reference type (create once)
@StateObject private var viewModel = UserListViewModel()
// @ObservedObject — non-owned reference type (passed in)
@ObservedObject var viewModel: UserDetailViewModel
```

## Observation Framework (iOS 17+)

```swift
@Observable
class UserViewModel {
    var users: [User] = []
    var isLoading = false

    func loadUsers() async {
        isLoading = true
        defer { isLoading = false }
        users = (try? await userService.fetchAll()) ?? []
    }
}

// No @Published needed — SwiftUI tracks property access automatically
struct UserListView: View {
    var viewModel = UserViewModel()
    var body: some View {
        List(viewModel.users) { Text($0.name) }
            .task { await viewModel.loadUsers() }
    }
}
```

## Navigation

```swift
enum Route: Hashable { case userDetail(User), settings }

NavigationStack(path: $path) {
    HomeView()
        .navigationDestination(for: Route.self) { route in
            switch route {
            case .userDetail(let user): UserDetailView(user: user)
            case .settings: SettingsView()
            }
        }
}
```

## Composition

- Extract reusable styling into `ViewModifier` structs
- Create extension methods on `View` for convenient `.cardStyle()` syntax
- Keep views small and composable — extract subviews as separate structs

## Anti-Patterns

```swift
// Never: massive body — extract subviews
// Never: business logic in views — use view model
// Never: @ObservedObject for view-created objects — use @StateObject
// Never: .onAppear { Task { } } — use .task { } for automatic cancellation
```
