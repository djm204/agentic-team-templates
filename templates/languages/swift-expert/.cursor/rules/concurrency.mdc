---
description: Swift Concurrency
alwaysApply: false
---

# Swift Concurrency

Structured concurrency with async/await, actors, and task groups.

## async/await

```swift
func fetchUser(id: UUID) async throws -> User {
    let (data, response) = try await urlSession.data(from: userURL(id))
    guard let http = response as? HTTPURLResponse, http.statusCode == 200 else {
        throw APIError.invalidResponse
    }
    return try JSONDecoder().decode(User.self, from: data)
}

// async let — parallel execution
async let user = fetchUser(id: userId)
async let orders = fetchOrders(userId: userId)
let dashboard = try await Dashboard(user: user, orders: orders)
```

## TaskGroup

```swift
func fetchAllUsers(ids: [UUID]) async throws -> [User] {
    try await withThrowingTaskGroup(of: User.self) { group in
        for id in ids { group.addTask { try await fetchUser(id: id) } }
        var users: [User] = []
        for try await user in group { users.append(user) }
        return users
    }
}

// Cancellation
func longProcess() async throws {
    for item in items {
        try Task.checkCancellation()
        await process(item)
    }
}
```

## Actors

```swift
actor ImageCache {
    private var cache: [URL: UIImage] = [:]
    func image(for url: URL) -> UIImage? { cache[url] }
    func store(_ image: UIImage, for url: URL) { cache[url] = image }
}

let image = await cache.image(for: url)  // await required for actor isolation
```

## Rules

- No `DispatchQueue.main.async` — use `@MainActor` or `MainActor.run`
- No completion handlers in new code — use `async`/`await`
- No `DispatchGroup` — use `TaskGroup`
- Always check `Task.isCancelled` in loops
- Mark types as `Sendable` when passed across concurrency domains
- Use actors for shared mutable state; prefer structured concurrency over `Task {}`

## Anti-Patterns

```swift
// Never: fire-and-forget Task without error handling
Task { try await riskyOp() }  // Errors silently swallowed
// Never: blocking main thread with DispatchQueue.main.sync
// Never: capturing self strongly in long-lived tasks — use [weak self]
// Never: GCD for new concurrent code — use async/await
```
