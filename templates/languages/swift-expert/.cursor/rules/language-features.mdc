---
description: Swift Language Features
alwaysApply: false
---

# Swift Language Features

Optionals, value types, enums, generics, and protocol-oriented design.

## Optionals

```swift
guard let user = fetchUser(id: userId) else {
    throw AppError.userNotFound(userId)
}
let displayName = user.nickname ?? user.fullName ?? "Anonymous"
let uppercased = user.email.map { $0.uppercased() }
// Never: user.email! — use guard/if let
```

## Value Types and Enums

```swift
struct User: Identifiable, Sendable {
    let id: UUID
    var name: String
    var email: String
}

enum LoadingState<T> {
    case idle, loading, loaded(T), failed(Error)
}

// Exhaustive switch — compiler enforces all cases
switch state {
case .idle: EmptyView()
case .loading: ProgressView()
case .loaded(let users): UserListView(users: users)
case .failed(let error): ErrorView(error: error)
}
```

## Protocols and Extensions

```swift
protocol Displayable {
    var displayName: String { get }
}

// Protocol composition
func showProfile(for entity: Identifiable & Displayable) { ... }

// Constrained extensions
extension Collection where Element: Identifiable {
    func element(withId id: Element.ID) -> Element? {
        first { $0.id == id }
    }
}
```

## Generics

```swift
func decode<T: Decodable>(_ type: T.Type, from data: Data) throws -> T {
    try JSONDecoder().decode(type, from: data)
}
// Opaque return types: func makeView() -> some View { ... }
// Primary associated types (5.7+): some Collection<User>
```

## Anti-Patterns

```swift
// Never: force-unwrapping — use guard/if let
// Never: class where struct suffices — unnecessary heap allocation
// Never: stringly-typed APIs — use enums
// Never: Any/AnyObject without cause — use generics or protocols
```
