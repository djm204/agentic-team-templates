---
description: Kotlin Coroutines
alwaysApply: false
---

# Kotlin Coroutines

Structured concurrency is the law. Every coroutine has a scope. Every scope has a lifecycle.

## Structured Concurrency

```kotlin
// Parallel decomposition — if any fails, ALL are cancelled
suspend fun loadDashboard(userId: UserId): Dashboard = coroutineScope {
  val user = async { userService.findById(userId) }
  val orders = async { orderService.findRecent(userId) }
  Dashboard(user = user.await(), orders = orders.await())
}
```

## Dispatchers

- `Dispatchers.IO` — blocking I/O (database, file, network)
- `Dispatchers.Default` — CPU-intensive computation
- `Dispatchers.Main` — UI thread (Android)
- Don't create custom thread pools unless you have a specific reason

## Flow

```kotlin
// Cold stream — values emitted on demand
fun observeUsers(): Flow<List<User>> = flow {
  while (true) { emit(userRepository.findAll()); delay(5.seconds) }
}

// StateFlow — hot observable with current value (replaces LiveData)
class UserViewModel : ViewModel() {
  private val _state = MutableStateFlow<UiState>(UiState.Loading)
  val state: StateFlow<UiState> = _state.asStateFlow()
  fun loadUser(id: UserId) { viewModelScope.launch {
    _state.value = UiState.Loading
    _state.value = try { UiState.Success(userService.findById(id)) } catch (e: Exception) { UiState.Error(e.message ?: "") }
  }}
}
```

## Cancellation

```kotlin
// Cooperative — coroutines must check for cancellation
suspend fun processItems(items: List<Item>) {
  for (item in items) { ensureActive(); process(item) }
}
// Timeout
val result = withTimeoutOrNull(5.seconds) { fetchDataFromNetwork() }
```

## Exception Handling

```kotlin
// supervisorScope — child failure doesn't cancel siblings
suspend fun fetchAllData(): DashboardData = supervisorScope {
  val user = async { fetchUser() }
  val orders = async { fetchOrders() } // If this fails, stats continues
  val stats = async { fetchStats() }
  DashboardData(user.await(), runCatching { orders.await() }.getOrDefault(emptyList()), stats.await())
}
```

## Anti-Patterns

- Never `GlobalScope` — no lifecycle, leaks coroutines
- Never `runBlocking` in production (except `main()` and tests)
- Never catch `CancellationException` without rethrowing
- Never `Thread.sleep()` — use `delay()`
