---
description: Kotlin Performance
alwaysApply: false
---

# Kotlin Performance

Profile first (JFR, JMH). Understand the JVM. Kotlin-specific optimizations matter.

## Inline Functions

```kotlin
// Eliminates lambda allocation — use for hot-path higher-order functions
inline fun <T> measure(label: String, block: () -> T): T {
  val start = System.nanoTime()
  return block().also { logger.debug { "$label took ${(System.nanoTime() - start) / 1_000_000}ms" } }
}
// reified: preserve generic type at runtime (only with inline)
inline fun <reified T> parseJson(json: String): T = objectMapper.readValue(json, T::class.java)
```

- Inline small, frequently-called HOFs; don't inline large bodies (code bloat)

## Value Classes

```kotlin
@JvmInline
value class UserId(val value: String) // Zero-overhead wrapper at runtime
@JvmInline
value class Email(val value: String) { init { require(value.contains("@")) { "Invalid email" } } }
```

## Sequences vs Collections

```kotlin
// Collections: eager, intermediate lists. Sequences: lazy, no intermediates
val result = users.asSequence()
  .filter { it.isActive }
  .map { it.name }
  .take(10)        // Stops after 10 matches
  .toList()        // Single terminal allocation
```

- Sequences for large collections (>1000), chaining, or `take`/`first` short-circuits
- Collections for small datasets or single operations

## Collection Optimization

```kotlin
// Pre-size collections
val map = HashMap<String, User>(expectedSize)
// buildList for single-allocation construction
val items = buildList(expectedSize) { for (item in source) { if (item.isValid) add(transform(item)) } }
// Use associateBy for O(1) lookup, mapTo(HashSet()) for uniqueness
val activeIds = activeUsers.map { it.id }.toSet()
orders.filter { it.userId in activeIds }
```

## Coroutine Performance

```kotlin
val channel = Channel<Event>(capacity = 64) // Buffered for throughput
// Only use withContext for actual blocking/CPU work
suspend fun hashPassword(pw: String): String = withContext(Dispatchers.Default) {
  BCrypt.hashpw(pw, BCrypt.gensalt())
}
```

## Anti-Patterns

- Never optimize without profiling — prove it with JFR or JMH
- Never create coroutines for non-suspending work
- Never use reflection in hot paths or mutable shared state without synchronization
