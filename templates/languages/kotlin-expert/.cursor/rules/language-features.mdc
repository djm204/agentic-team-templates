---
description: Kotlin Language Features
alwaysApply: false
---

# Kotlin Language Features

Every feature exists for safety, clarity, or expressiveness. Use deliberately.

## Null Safety

```kotlin
val displayName = user?.name ?: "Anonymous"
val userId = request.userId ?: throw IllegalArgumentException("userId required")
// Never: user!!.name — use requireNotNull(user) { "reason" }
val number = value as? Int // Safe cast: null if not Int
```

- `!!` is a code smell — every usage needs a comment explaining why it's safe
- Prefer `requireNotNull()`/`checkNotNull()` for meaningful error messages
- Use `?.let { }` for nullable transformations

## Data Classes and Value Classes

```kotlin
data class Order(val id: OrderId, val items: List<OrderItem>, val status: OrderStatus)
val updated = order.copy(status = OrderStatus.SHIPPED)

@JvmInline
value class UserId(val value: String) { init { require(value.isNotBlank()) { "blank" } } }
```

## Sealed Types

```kotlin
sealed interface Result<out T> {
  data class Success<T>(val value: T) : Result<T>
  data class Failure(val error: AppError) : Result<Nothing>
}
// Exhaustive when — add a subtype, get compile errors everywhere
fun describe(r: Result<User>): String = when (r) {
  is Result.Success -> "User: ${r.value.name}"
  is Result.Failure -> "Error: ${r.error}"
}
```

## Extension Functions

```kotlin
fun String.toSlug(): String = lowercase().replace(Regex("[^a-z0-9\\s-]"), "").replace(Regex("\\s+"), "-")
fun List<Order>.totalRevenue(): BigDecimal = filter { it.status == OrderStatus.COMPLETED }.sumOf { it.total }
val String.isValidEmail: Boolean get() = matches(Regex("^[^@]+@[^@]+\\.[^@]+$"))
```

## Scope Functions

- `let` — nullable chains, scoped transformations: `name?.let { it.trim().length }`
- `apply` — object configuration: `HttpClient().apply { timeout = 30.seconds }`
- `run` — compute result from receiver: `StringBuilder().run { append("a"); toString() }`
- `also` — side effects: `createUser(req).also { logger.info("Created: ${it.id}") }`
- `with` — multiple operations on same object (avoid for nullable)

## Collections

```kotlin
val (active, inactive) = users.partition { it.isActive }
val byId = users.associateBy { it.id }
// Sequences for large collections
val top10 = users.asSequence().filter { it.isActive }.map { it.name }.take(10).toList()
// buildList for single-allocation construction
val items = buildList { add("first"); addAll(existing); if (extra) add("extra") }
```

## Anti-Patterns

- Never `!!` without justification — NPE waiting to happen
- Never `MutableList` in public APIs — expose `List`
- Never `else` on sealed `when` — let the compiler catch missing cases
