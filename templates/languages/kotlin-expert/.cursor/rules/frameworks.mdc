---
description: Kotlin Frameworks
alwaysApply: false
---

# Kotlin Frameworks

Ktor for Kotlin-first, Spring Boot for ecosystem breadth. Both done idiomatically.

## Ktor

```kotlin
fun Application.configureRouting() {
  routing { route("/api/v1") { userRoutes(); orderRoutes() } }
}
fun Route.userRoutes() {
  route("/users") {
    get("/{id}") {
      val id = UserId(call.parameters["id"] ?: return@get call.respond(HttpStatusCode.BadRequest))
      when (val result = userService.findById(id)) {
        is Result.Success -> call.respond(result.value)
        is Result.Failure -> call.respond(HttpStatusCode.NotFound)
      }
    }
    post {
      val request = call.receive<CreateUserRequest>()
      when (val result = userService.create(request)) {
        is Result.Success -> call.respond(HttpStatusCode.Created, result.value)
        is Result.Failure -> call.respond(HttpStatusCode.BadRequest, result.error)
      }
    }
  }
}
```

## Spring Boot

```kotlin
@RestController
@RequestMapping("/api/v1/orders")
class OrderController(private val orderService: OrderService) {
  @GetMapping("/{id}")
  suspend fun getById(@PathVariable id: UUID): ResponseEntity<OrderResponse> =
    orderService.findById(OrderId(id.toString()))
      ?.let { ResponseEntity.ok(OrderResponse.from(it)) }
      ?: ResponseEntity.notFound().build()
}
```

## Exposed (Kotlin SQL)

```kotlin
object Users : Table("users") {
  val id = uuid("id").autoGenerate()
  val name = varchar("name", 200)
  val email = varchar("email", 255).uniqueIndex()
  override val primaryKey = PrimaryKey(id)
}
class UserRepository(private val db: Database) {
  suspend fun findByEmail(email: String): User? = newSuspendedTransaction(Dispatchers.IO) {
    Users.selectAll().where { Users.email eq email }.map { it.toUser() }.singleOrNull()
  }
}
```

## Koin (DI)

```kotlin
val appModule = module { single { UserRepository(get()) }; factory { UserService(get(), get()) } }
fun Application.configureKoin() { install(Koin) { modules(appModule) } }
```

## Anti-Patterns

- Never blocking calls in coroutine context — use suspend-compatible clients
- Never expose `MutableList` from services; never Java-style builders — use named args + `copy()`
