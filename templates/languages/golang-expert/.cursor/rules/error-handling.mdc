---
description: Go Error Handling
alwaysApply: false
---

# Go Error Handling

Errors are values — the primary control flow for failure cases.

## Always Handle Errors

```go
// Good: every error handled with context
f, err := os.Open(filename)
if err != nil { return fmt.Errorf("opening config file: %w", err) }
defer f.Close()

// Bad: silently discarding
f, _ := os.Open(filename)
```

## Wrap With Context

```go
// Each layer adds what it was doing
return fmt.Errorf("getting user by email %q: %w", email, err)
// Use %w when callers should unwrap. Use %v to break chain across API boundaries.
```

## Sentinel Errors and Custom Types

```go
var ErrNotFound = errors.New("not found")
if errors.Is(err, ErrNotFound) { http.Error(w, "not found", 404) }

type ValidationError struct{ Field, Message string }
func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation: %s: %s", e.Field, e.Message)
}
var ve *ValidationError
if errors.As(err, &ve) { /* access ve.Field */ }
```

## The run() Pattern

```go
func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
}
```

## HTTP Handler Errors

```go
type appHandler func(w http.ResponseWriter, r *http.Request) error

func (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    if err := fn(w, r); err != nil {
        switch {
        case errors.Is(err, ErrNotFound):
            http.Error(w, "not found", 404)
        default:
            slog.Error("internal error", "error", err)
            http.Error(w, "internal server error", 500)
        }
    }
}
```

## Anti-Patterns

- **Never** `panic` for expected errors — only in `init()` or test helpers
- **Never** check `err.Error() == "..."` — use `errors.Is`/`errors.As`
- **Never** return both a valid value and a non-nil error
