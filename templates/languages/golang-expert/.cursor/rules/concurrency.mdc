---
description: Go Concurrency
alwaysApply: false
---

# Go Concurrency

Concurrency is Go's defining feature — and the easiest way to write unreproducible bugs.

## Fundamental Rules

- **Don't start a goroutine you can't stop** — every goroutine must respect `ctx.Done()`
- **The caller decides concurrency** — write synchronous functions, let callers `go` them
- **Share memory by communicating** — channels for ownership transfer, mutexes for simple state

## errgroup (Primary Pattern)

```go
g, ctx := errgroup.WithContext(ctx)
for i, url := range urls {
    g.Go(func() error {
        resp, err := fetch(ctx, url)
        if err != nil { return err }
        responses[i] = resp
        return nil
    })
}
if err := g.Wait(); err != nil { return nil, err }
```

## Bounded Concurrency
```go
sem := make(chan struct{}, maxConcurrent)
g, ctx := errgroup.WithContext(ctx)
for _, item := range items {
    g.Go(func() error {
        sem <- struct{}{}
        defer func() { <-sem }()
        return process(ctx, item)
    })
}
return g.Wait()
```

## Channel Pipeline

```go
func pipeline(ctx context.Context, in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for v := range in {
            select { case <-ctx.Done(): return; case out <- v * 2: }
        }
    }()
    return out
}
```

## sync Primitives

- `sync.WaitGroup` — `Add` before launching goroutine, `Done` in defer
- `sync.Once` — lazy thread-safe init
- `sync.Map` — only for write-once/read-many; otherwise map + Mutex

## Context Rules

- First parameter always. Never store in a struct. Always `defer cancel()`.
- Values: only for request-scoped cross-cutting data (trace IDs)

## Race Detection

Always `go test -race ./...` in CI. Zero false positives — every report is a real bug.

## Anti-Patterns

- `go doSomething()` without ownership — who waits? who handles errors?
- `time.Sleep` for synchronization — use sync primitives
- Unbounded goroutines — use semaphores or bounded workers
