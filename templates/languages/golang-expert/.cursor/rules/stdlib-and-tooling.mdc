---
description: Go Standard Library and Tooling
alwaysApply: false
---

# Go Standard Library and Tooling

Know the stdlib deeply before reaching for third-party packages.

## net/http (Production-Ready)

```go
mux := http.NewServeMux()
mux.HandleFunc("GET /users/{id}", getUser)
srv := &http.Server{
    Addr: ":8080", Handler: mux,
    ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second,
}
// Always set timeouts — no-timeout servers leak goroutines
```

## encoding/json

```go
type User struct {
    ID   string `json:"id"`
    Name string `json:"name,omitempty"`
}
// json.NewDecoder for streams; DisallowUnknownFields() to reject extra fields
```

## log/slog

```go
logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
logger.Info("request", "method", r.Method, "path", r.URL.Path, "duration", elapsed)
```

## context

- First parameter, always. Never store in a struct. Always `defer cancel()`.
- Values: sparingly, only for request-scoped cross-cutting concerns (trace IDs)

## io

`io.Reader`/`io.Writer` are universal — accepting `io.Reader` works with files, HTTP bodies, buffers, strings, gzip, network connections.

## time

- `time.Duration` for durations, never raw int64
- `time.NewTicker` not `time.Tick` (Tick leaks)
- `time.Since(start)` for elapsed (monotonic)

## Essential Commands

```bash
go test -race ./...      # Tests with race detection (always in CI)
go vet ./...             # Static analysis
golangci-lint run        # Comprehensive linting
go mod tidy              # Clean up dependencies
```

## When to Use Third-Party

Use stdlib unless:
- It genuinely lacks the capability (database drivers, protobuf)
- A well-maintained package provides significantly better ergonomics (`sqlc`, `chi`)
- The package is from Go's extended ecosystem (`golang.org/x/...`)
