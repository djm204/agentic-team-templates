---
description: Go Testing
alwaysApply: false
---

# Go Testing

Tests in `_test.go`, run with `go test`. Built into the toolchain.

## Table-Driven Tests

```go
func TestParseAge(t *testing.T) {
    tests := []struct{ name, input string; want int; wantErr bool }{
        {"valid", "25", 25, false}, {"negative", "-1", 0, true},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ParseAge(tt.input)
            if tt.wantErr { if err == nil { t.Error("expected error") }; return }
            if err != nil { t.Fatalf("unexpected: %v", err) }
            if got != tt.want { t.Errorf("got %d, want %d", got, tt.want) }
        })
    }
}
```

## Test Helpers

```go
func setupTestDB(t *testing.T) *sql.DB {
    t.Helper()
    db, err := sql.Open("sqlite", ":memory:")
    if err != nil { t.Fatalf("opening test db: %v", err) }
    t.Cleanup(func() { db.Close() })
    return db
}
```

## Fakes via Interfaces

```go
type fakeStore struct { users map[string]*User; err error }
func (f *fakeStore) GetByID(_ context.Context, id string) (*User, error) {
    if f.err != nil { return nil, f.err }
    u, ok := f.users[id]
    if !ok { return nil, ErrNotFound }
    return u, nil
}
```

## HTTP Handler Tests

```go
req := httptest.NewRequest("GET", "/users/123", nil)
rec := httptest.NewRecorder()
srv.ServeHTTP(rec, req)
if rec.Code != 200 { t.Errorf("status = %d, want 200", rec.Code) }
```

## go-cmp

```go
if diff := cmp.Diff(want, got); diff != "" {
    t.Errorf("mismatch (-want +got):\n%s", diff)
}
```

## Race Detection

Always `go test -race ./...` in CI. Zero false positives — every report is a bug.

## Anti-Patterns

- **Never** tests that depend on execution order
- **Never** `time.Sleep` for sync — use channels or WaitGroups
- **Never** test unexported functions — test the public API
