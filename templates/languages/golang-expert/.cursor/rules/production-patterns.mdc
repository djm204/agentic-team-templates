---
description: Go Production Patterns
alwaysApply: false
---

# Go Production Patterns

Patterns for Go services that run reliably in production.

## The run() Pattern

```go
func main() {
    ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
    defer cancel()
    if err := run(ctx, os.Stdout, os.Args[1:]); err != nil {
        fmt.Fprintf(os.Stderr, "error: %v\n", err)
        os.Exit(1)
    }
}
func run(ctx context.Context, stdout io.Writer, args []string) error {
    cfg, err := loadConfig()
    if err != nil { return fmt.Errorf("loading config: %w", err) }
    db, err := connectDB(ctx, cfg.DatabaseURL)
    if err != nil { return fmt.Errorf("connecting to db: %w", err) }
    defer db.Close()
    srv := &http.Server{Addr: cfg.Addr, Handler: NewServer(db)}
    go func() { srv.ListenAndServe() }()
    <-ctx.Done()
    shutdownCtx, c := context.WithTimeout(context.Background(), 10*time.Second)
    defer c()
    return srv.Shutdown(shutdownCtx)
}
```

## Dependency Injection

Wire explicitly in `run()` — no magic. Infrastructure → Repos → Services → Handlers → Server.

## Configuration

Validate all config at startup — fail fast. Use env vars with required/default tags.

## Health Checks

```go
mux.HandleFunc("GET /healthz", func(w http.ResponseWriter, r *http.Request) {
    if err := db.PingContext(r.Context()); err != nil {
        http.Error(w, "unhealthy", 503); return
    }
    w.Write([]byte(`{"status":"ok"}`))
})
```

## Observability

- `slog` with JSON output, consistent field names
- Log levels: Debug (dev), Info (normal ops), Warn (handled), Error (needs attention)
- Never log sensitive data; Prometheus metrics for requests/latency

## Database Transactions

```go
func WithTx(ctx context.Context, db *sql.DB, fn func(context.Context, *sql.Tx) error) error {
    tx, err := db.BeginTx(ctx, nil)
    if err != nil { return err }
    if err := fn(ctx, tx); err != nil { tx.Rollback(); return err }
    return tx.Commit()
}
```

## Anti-Patterns

- **Never** global mutable state (`var db *sql.DB`) — inject dependencies
- **Never** `context.Background()` in handlers — use `r.Context()`
- **Never** unbounded work queues — handle backpressure explicitly
