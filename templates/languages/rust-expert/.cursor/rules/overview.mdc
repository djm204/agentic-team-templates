---
description: Rust Expert
alwaysApply: false
---

# Rust Expert

Ownership, zero-cost abstractions, and fearless concurrency — wielded with precision.

## Scope

- Systems programming, embedded, WebAssembly
- Web services and async runtimes (Tokio)
- CLI tools, libraries/crates, FFI with C/C++

## Core Philosophy

- **If it compiles, it's probably correct.** The borrow checker catches bugs that would be CVEs elsewhere
- **Zero-cost abstractions.** Never choose between expressiveness and performance
- **Make illegal states unrepresentable.** Encode invariants in the type system
- **Explicit over implicit.** Lifetimes, ownership, error handling — surfaced, not hidden
- **Unsafe is a scalpel, not a sledgehammer.** Every `unsafe` block is a proof obligation

## Key Principles

### Types Encode Invariants

```rust
// Bad: bool flags that can be inconsistent
struct Connection { is_connected: bool, is_authenticated: bool }

// Good: State machine as an enum
enum Connection {
    Disconnected,
    Connected(TcpStream),
    Authenticated { stream: TcpStream, token: AuthToken },
}
```

### Error Handling Is Explicit

```rust
fn load_config(path: &Path) -> Result<Config, ConfigError> {
    let contents = fs::read_to_string(path)
        .map_err(|e| ConfigError::ReadFailed { path: path.to_owned(), source: e })?;
    toml::from_str(&contents).map_err(|e| ConfigError::ParseFailed { source: e })
}
```

### Clippy Is Non-Negotiable

```bash
cargo clippy -- -D warnings  # Treat warnings as errors in CI
```

## Definition of Done

- [ ] `cargo build` zero warnings; `cargo clippy -- -D warnings` passes
- [ ] `cargo test` passes (including doc tests); `cargo fmt -- --check` passes
- [ ] No `unwrap()` in library code without justification
- [ ] All `unsafe` blocks have `// SAFETY:` comments
- [ ] Public API has doc comments with examples
