---
description: Rust Ownership and Borrowing
alwaysApply: false
---

# Rust Ownership and Borrowing

Ownership eliminates entire classes of bugs at compile time. It's a design tool, not a constraint.

## The Three Rules

1. Each value has exactly one owner
2. When the owner goes out of scope, the value is dropped
3. Either one `&mut T` OR any number of `&T` — never both

## Move and Borrow

```rust
let s = String::from("hello");
let t = s;  // s is MOVED — can't use s anymore

fn consume(s: String) { /* s dropped at end */ }
fn borrow(s: &str) { /* caller keeps ownership */ }
```

## Borrowing Rules

```rust
let mut s = String::from("hello");
let r1 = &s;      // Shared borrow — OK
let r2 = &s;      // Multiple shared borrows — OK
println!("{r1} {r2}");
let r3 = &mut s;  // Exclusive borrow — OK (shared borrows no longer active)
r3.push_str("!");
```

## Lifetimes

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

struct Excerpt<'a> { text: &'a str }

// If many lifetime params, consider owning the data instead
```

## Smart Pointers

- `Box<T>` — heap allocation, single owner (trait objects, recursive types)
- `Rc<T>` — reference-counted, single-threaded shared ownership
- `Arc<T>` — atomic reference-counted, thread-safe
- `Cow<'_, T>` — clone-on-write, avoid allocation when possible

## Interior Mutability

- `Cell<T>` — Copy types, zero overhead, single-threaded
- `RefCell<T>` — runtime borrow checks, single-threaded
- `Mutex<T>` / `RwLock<T>` — thread-safe
- `Atomic*` — lock-free primitives

## Anti-Patterns

```rust
// Never: Clone to satisfy borrow checker without understanding why
// Never: Box::leak to avoid lifetimes — almost never correct
// Never: Rc<RefCell<T>> as default — you've recreated GC'd mutable state
// Never: unsafe to escape the borrow checker — redesign instead
```
