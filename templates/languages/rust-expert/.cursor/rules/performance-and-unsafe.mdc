---
description: Rust Performance and Unsafe
alwaysApply: false
---

# Rust Performance and Unsafe

Zero-cost abstractions mean you rarely choose between ergonomics and performance. When you go lower, `unsafe` comes with strict obligations.

## Measure First

```bash
cargo bench                     # Benchmarks
cargo flamegraph                # Flamegraph
cargo build --timings           # Compile time per crate
cargo bloat --release --crates  # Binary size by crate
```

## Allocation Patterns

```rust
// Preallocate when size is known
let mut results = Vec::with_capacity(items.len());

// Iterators avoid allocation entirely
let sum: i64 = items.iter().filter(|x| x.is_valid()).map(|x| x.value()).sum();

// Cow for conditional ownership
fn normalize(input: &str) -> Cow<'_, str> {
    if input.contains('\t') {
        Cow::Owned(input.replace('\t', "    "))
    } else {
        Cow::Borrowed(input)  // Zero allocation
    }
}
```

## Key Performance Patterns

- `Vec::with_capacity` / `String::with_capacity` — preallocate
- Iterators over collect-then-iterate — avoid intermediate allocations
- `SmallVec` for small stack-allocated collections
- `std::fmt::Write` for string building
- Avoid unnecessary clones: borrow when possible, own when needed

## Unsafe Contract

Every `unsafe` block is a proof obligation:

```rust
// SAFETY: index verified within bounds on line 42,
// slice valid for the lifetime of this function.
unsafe { *ptr.add(index) = value; }
```

## Valid Uses of Unsafe

- FFI: calling C functions, implementing `Send`/`Sync` with proof
- Unchecked operations after profiling proves it matters
- **Always** wrap unsafe in safe abstractions with narrow interfaces
- Run `cargo +nightly miri test` in CI for crates with unsafe

## Anti-Patterns

```rust
// Never: unsafe to "shut up the borrow checker" — redesign instead
// Never: unsafe without a // SAFETY: comment
// Never: transmute as first resort — use safe alternatives (to_bits, from_bits)
// Never: Assume memory layout without repr(C)
```
